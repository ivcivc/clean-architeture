// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/devfullcycle/20-CleanArch/internal/infra/graph/model"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers: cfg.Resolvers,
	}
}

type Config struct {
	Resolvers ResolverRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type MutationResolver interface {
	CreateOrder(ctx context.Context, input *model.OrderInput) (*model.Order, error)
}

type QueryResolver interface {
	ListOrders(ctx context.Context) ([]*model.Order, error)
}

type executableSchema struct {
	resolvers ResolverRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			if data != nil {
				data.MarshalGQL(&buf)
			}
			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			if data != nil {
				data.MarshalGQL(&buf)
			}
			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nil)
	out := graphql.NewFieldSet(fields)
	
	for i, field := range fields {
		switch field.Name {
		case "listOrders":
			out.Values[i] = ec._Query_listOrders(ctx, field)
		}
	}
	out.Dispatch()
	return out
}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nil)
	out := graphql.NewFieldSet(fields)
	
	for i, field := range fields {
		switch field.Name {
		case "createOrder":
			out.Values[i] = ec._Mutation_createOrder(ctx, field)
		}
	}
	out.Dispatch()
	return out
}

func (ec *executionContext) _Query_listOrders(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	resTmp, err := ec.resolvers.Query().ListOrders(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	return ec.marshalOrderArray(ctx, field.Selections, resTmp)
}

func (ec *executionContext) _Mutation_createOrder(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	input := &model.OrderInput{}
	
	if tmp, ok := rawArgs["input"]; ok {
		if inputMap, ok := tmp.(map[string]interface{}); ok {
			if id, ok := inputMap["id"].(string); ok {
				input.ID = id
			}
			if price, ok := inputMap["price"].(float64); ok {
				input.Price = price
			}
			if tax, ok := inputMap["tax"].(float64); ok {
				input.Tax = tax
			}
		}
	}
	
	resTmp, err := ec.resolvers.Mutation().CreateOrder(ctx, input)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	return ec.marshalOrder(ctx, field.Selections, resTmp)
}

func (ec *executionContext) marshalOrderArray(ctx context.Context, sel ast.SelectionSet, v []*model.Order) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOrder(ctx, sel, v[i])
	}
	return ret
}

func (ec *executionContext) marshalOrder(ctx context.Context, sel ast.SelectionSet, obj *model.Order) graphql.Marshaler {
	if obj == nil {
		return graphql.Null
	}
	
	fields := graphql.CollectFields(ec.OperationContext, sel, nil)
	out := graphql.NewFieldSet(fields)
	
	for i, field := range fields {
		switch field.Name {
		case "id":
			out.Values[i] = graphql.MarshalString(obj.ID)
		case "price":
			out.Values[i] = graphql.MarshalFloat(obj.Price)
		case "tax":
			out.Values[i] = graphql.MarshalFloat(obj.Tax)
		case "finalPrice":
			out.Values[i] = graphql.MarshalFloat(obj.FinalPrice)
		}
	}
	out.Dispatch()
	return out
}

var parsedSchema = gqlparser.MustLoadSchema(&ast.Source{
	Name: "schema.graphqls", 
	Input: `type Order {
    id: String!
    price: Float!
    tax: Float!
    finalPrice: Float!
}

input OrderInput {
    id: String!
    price: Float!
    tax: Float!
}

type Mutation {
    createOrder(input: OrderInput): Order
}

type Query {
    listOrders: [Order]
}`,
}) 